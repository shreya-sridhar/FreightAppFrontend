{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\n\nvar InternetReachability = function InternetReachability(configuration, listener) {\n  var _this = this;\n\n  _classCallCheck(this, InternetReachability);\n\n  this._isInternetReachable = undefined;\n  this._currentInternetReachabilityCheckHandler = null;\n  this._currentTimeoutHandle = null;\n\n  this._setIsInternetReachable = function (isInternetReachable) {\n    if (_this._isInternetReachable === isInternetReachable) {\n      return;\n    }\n\n    _this._isInternetReachable = isInternetReachable;\n\n    _this._listener(_this._isInternetReachable);\n  };\n\n  this._setExpectsConnection = function (expectsConnection) {\n    if (_this._currentInternetReachabilityCheckHandler !== null) {\n      _this._currentInternetReachabilityCheckHandler.cancel();\n\n      _this._currentInternetReachabilityCheckHandler = null;\n    }\n\n    if (_this._currentTimeoutHandle !== null) {\n      clearTimeout(_this._currentTimeoutHandle);\n      _this._currentTimeoutHandle = null;\n    }\n\n    if (expectsConnection) {\n      if (!_this._isInternetReachable) {\n        _this._setIsInternetReachable(null);\n      }\n\n      _this._currentInternetReachabilityCheckHandler = _this._checkInternetReachability();\n    } else {\n      _this._setIsInternetReachable(false);\n    }\n  };\n\n  this._checkInternetReachability = function () {\n    var responsePromise = fetch(_this._configuration.reachabilityUrl, {\n      method: 'HEAD',\n      cache: 'no-cache'\n    });\n    var timeoutHandle;\n    var timeoutPromise = new Promise(function (_, reject) {\n      timeoutHandle = setTimeout(function () {\n        return reject('timedout');\n      }, _this._configuration.reachabilityRequestTimeout);\n    });\n\n    var cancel = function cancel() {};\n\n    var cancelPromise = new Promise(function (_, reject) {\n      cancel = function cancel() {\n        return reject('canceled');\n      };\n    });\n    var promise = Promise.race([responsePromise, timeoutPromise, cancelPromise]).then(function (response) {\n      return _this._configuration.reachabilityTest(response);\n    }).then(function (result) {\n      _this._setIsInternetReachable(result);\n\n      var nextTimeoutInterval = _this._isInternetReachable ? _this._configuration.reachabilityLongTimeout : _this._configuration.reachabilityShortTimeout;\n      _this._currentTimeoutHandle = setTimeout(_this._checkInternetReachability, nextTimeoutInterval);\n    }).catch(function (error) {\n      if (error !== 'canceled') {\n        _this._setIsInternetReachable(false);\n\n        _this._currentTimeoutHandle = setTimeout(_this._checkInternetReachability, _this._configuration.reachabilityShortTimeout);\n      }\n    }).then(function () {\n      clearTimeout(timeoutHandle);\n    }, function (error) {\n      clearTimeout(timeoutHandle);\n      throw error;\n    });\n    return {\n      promise: promise,\n      cancel: cancel\n    };\n  };\n\n  this.update = function (state) {\n    if (typeof state.isInternetReachable === 'boolean') {\n      _this._setIsInternetReachable(state.isInternetReachable);\n    } else {\n      _this._setExpectsConnection(state.isConnected);\n    }\n  };\n\n  this.currentState = function () {\n    return _this._isInternetReachable;\n  };\n\n  this.tearDown = function () {\n    if (_this._currentInternetReachabilityCheckHandler !== null) {\n      _this._currentInternetReachabilityCheckHandler.cancel();\n\n      _this._currentInternetReachabilityCheckHandler = null;\n    }\n\n    if (_this._currentTimeoutHandle !== null) {\n      clearTimeout(_this._currentTimeoutHandle);\n      _this._currentTimeoutHandle = null;\n    }\n  };\n\n  this._configuration = configuration;\n  this._listener = listener;\n};\n\nexport { InternetReachability as default };","map":{"version":3,"sources":["internetReachability.ts"],"names":["InternetReachability","_isInternetReachable","undefined","_currentInternetReachabilityCheckHandler","_currentTimeoutHandle","clearTimeout","responsePromise","fetch","method","cache","timeoutPromise","timeoutHandle","setTimeout","reject","cancel","cancelPromise","promise","Promise","nextTimeoutInterval","error","state"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport * as Types from './types';\nimport * as PrivateTypes from './privateTypes';\n\ninterface InternetReachabilityCheckHandler {\n  promise: Promise<void>;\n  cancel: () => void;\n}\n\nexport default class InternetReachability {\n  private _configuration: Types.NetInfoConfiguration;\n  private _listener: PrivateTypes.NetInfoInternetReachabilityChangeListener;\n  private _isInternetReachable: boolean | null | undefined = undefined;\n  private _currentInternetReachabilityCheckHandler: InternetReachabilityCheckHandler | null = null;\n  private _currentTimeoutHandle: ReturnType<typeof setTimeout> | null = null;\n\n  constructor(\n    configuration: Types.NetInfoConfiguration,\n    listener: PrivateTypes.NetInfoInternetReachabilityChangeListener,\n  ) {\n    this._configuration = configuration;\n    this._listener = listener;\n  }\n\n  private _setIsInternetReachable = (\n    isInternetReachable: boolean | null | undefined,\n  ): void => {\n    if (this._isInternetReachable === isInternetReachable) {\n      return;\n    }\n\n    this._isInternetReachable = isInternetReachable;\n    this._listener(this._isInternetReachable);\n  };\n\n  private _setExpectsConnection = (expectsConnection: boolean): void => {\n    // Cancel any pending check\n    if (this._currentInternetReachabilityCheckHandler !== null) {\n      this._currentInternetReachabilityCheckHandler.cancel();\n      this._currentInternetReachabilityCheckHandler = null;\n    }\n    // Cancel any pending timeout\n    if (this._currentTimeoutHandle !== null) {\n      clearTimeout(this._currentTimeoutHandle);\n      this._currentTimeoutHandle = null;\n    }\n\n    if (expectsConnection) {\n      // If we expect a connection, start the process for finding if we have one\n      // Set the state to \"null\" if it was previously false\n      if (!this._isInternetReachable) {\n        this._setIsInternetReachable(null);\n      }\n      // Start a network request to check for internet\n      this._currentInternetReachabilityCheckHandler = this._checkInternetReachability();\n    } else {\n      // If we don't expect a connection, just change the state to \"false\"\n      this._setIsInternetReachable(false);\n    }\n  };\n\n  private _checkInternetReachability = (): InternetReachabilityCheckHandler => {\n    const responsePromise = fetch(this._configuration.reachabilityUrl, {\n      method: 'HEAD',\n      cache: 'no-cache',\n    });\n\n    // Create promise that will reject after the request timeout has been reached\n    let timeoutHandle: ReturnType<typeof setTimeout>;\n    const timeoutPromise = new Promise<Response>(\n      (_, reject): void => {\n        timeoutHandle = setTimeout(\n          (): void => reject('timedout'),\n          this._configuration.reachabilityRequestTimeout,\n        );\n      },\n    );\n\n    // Create promise that makes it possible to cancel a pending request through a reject\n    let cancel: () => void = (): void => {};\n    const cancelPromise = new Promise<Response>(\n      (_, reject): void => {\n        cancel = (): void => reject('canceled');\n      },\n    );\n\n    const promise = Promise.race([\n      responsePromise,\n      timeoutPromise,\n      cancelPromise,\n    ])\n      .then(\n        (response): Promise<boolean> => {\n          return this._configuration.reachabilityTest(response);\n        },\n      )\n      .then(\n        (result): void => {\n          this._setIsInternetReachable(result);\n          const nextTimeoutInterval = this._isInternetReachable\n            ? this._configuration.reachabilityLongTimeout\n            : this._configuration.reachabilityShortTimeout;\n          this._currentTimeoutHandle = setTimeout(\n            this._checkInternetReachability,\n            nextTimeoutInterval,\n          );\n        },\n      )\n      .catch(\n        (error: Error | 'timedout' | 'canceled'): void => {\n          if (error !== 'canceled') {\n            this._setIsInternetReachable(false);\n            this._currentTimeoutHandle = setTimeout(\n              this._checkInternetReachability,\n              this._configuration.reachabilityShortTimeout,\n            );\n          }\n        },\n      )\n      // Clear request timeout and propagate any errors\n      .then(\n        (): void => {\n          clearTimeout(timeoutHandle);\n        },\n        (error: Error): void => {\n          clearTimeout(timeoutHandle);\n          throw error;\n        },\n      );\n\n    return {\n      promise,\n      cancel,\n    };\n  };\n\n  public update = (state: PrivateTypes.NetInfoNativeModuleState): void => {\n    if (typeof state.isInternetReachable === 'boolean') {\n      this._setIsInternetReachable(state.isInternetReachable);\n    } else {\n      this._setExpectsConnection(state.isConnected);\n    }\n  };\n\n  public currentState = (): boolean | null | undefined => {\n    return this._isInternetReachable;\n  };\n\n  public tearDown = (): void => {\n    // Cancel any pending check\n    if (this._currentInternetReachabilityCheckHandler !== null) {\n      this._currentInternetReachabilityCheckHandler.cancel();\n      this._currentInternetReachabilityCheckHandler = null;\n    }\n\n    // Cancel any pending timeout\n    if (this._currentTimeoutHandle !== null) {\n      clearTimeout(this._currentTimeoutHandle);\n      this._currentTimeoutHandle = null;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}